## Last Session: Implement retry policy for empty sessions (simple-agent-harness-jr7)

### Completed
- Implemented retry.rs with full empty-session retry policy:
  - `RetryDecision` enum: Proceed, Retry { attempt }, Skip
  - `RetryPolicy` struct: tracks max_retries, min_output_bytes, current_attempt
  - `new()`: creates policy from config values (max_empty_retries, min_output_bytes)
  - `evaluate(output_bytes)`: returns Proceed if sufficient, Retry if attempts remain, Skip if exhausted
  - `reset()`: clears attempt counter for new iteration
  - `current_attempt()`: accessor for current retry count
  - Logs warnings via tracing when retrying or skipping
- 10 tests covering:
  - proceed_when_output_sufficient: >= threshold returns Proceed
  - retry_when_output_empty: 0 bytes triggers retry
  - retry_when_output_below_threshold: just under threshold triggers retry
  - skip_after_max_retries_exhausted: 3rd attempt with max=2 returns Skip
  - reset_clears_attempt_counter: reset enables fresh retries
  - zero_max_retries_skips_immediately: 0 retries = instant skip
  - proceed_does_not_increment_attempt: successful sessions don't count
  - proceed_after_retry_when_output_recovers: mid-retry recovery works
  - exact_threshold_proceeds: boundary test
  - min_output_zero_always_proceeds: 0 threshold = never retry
- All 38 tests pass (10 config + 12 session + 6 watchdog + 10 retry), clippy clean, fmt applied

### Current State
- Retry policy is fully functional and tested
- Unblocks: runner loop (p0y) which depends on retry (jr7), session (d3v, done), and watchdog (fvr, done)
- Signal handling (7rx) is also still needed before runner can proceed

### Suggested Next Tasks
- Implement signal handling (simple-agent-harness-7rx) — P1, unblocked
- Implement structured console logging (simple-agent-harness-yyb) — P2, unblocked
- After 7rx is done, runner loop (p0y) should be unblocked
